# to contain all core function for swapping between builds 37 and 38 on a large number of variants
# core will be mapping to a bim file, using liftover to convert and then mergeing back in to the original format
# ensure check_for_liftover() is called before annotating

#' Create a BED file from a data frame
#' 
#' This function takes a data frame and creates a BED file from it.
#' Requires only chromosome and position to do so.
#' Note this assumes that for all positions you are working with 
#' SNPs and not indels, so here all positions are 1bp long.
#' 
#' @param data A data frame with at least chromosome and position columns
#' @param chrom The name of the column containing chromosome information. Default is "chr".
#' @param position The name of the column containing position information. Default is "pos".
#' 
#' @return A data frame with chromosome, position0, and position columns
#' 
#' @export
to_bed <- function(data, chrom = "chr", position = "pos") {
  data <- data %>%
    tibble::as_tibble() %>%
    dplyr::mutate(pos0 = .data[[position]]) %>%
    dplyr::select({{ chrom }}, pos0 , {{ position }})
  
  colnames(data) <- c("chr", "pos0", "pos1")
  
  return(data)
}

#' Read in unmapped variants
#' 
#' This function reads in a file of unmapped variants and returns a data frame,
#' where the unmapped variants are output generated by the liftover tool.
#' 
#' @param filename The name of the file containing unmapped variants
#' 
#' @return A data frame with chromosome, position0, and position1 columns
#' 
#' @export
read_unmapped_variants <- function(filename) {
  # Read the file and filter out lines starting with '#'
  lines <- readr::read_lines(filename) %>%
    purr::keep(~ !stringr::str_starts(., '#'))
  
  if (length(lines) > 0) {
    # Convert lines to a single string and read into a data frame
    df <- readr::read_table(text = paste(lines, collapse = "\n"),
                            col_names = c('CHROM', 'POS_0', 'POS_1')) %>%
      dplyr::mutate(CHROM = stringr::str_replace_all(CHROM, "chr", ""))
      
    n_unmapped <- nrow(df)
    message(paste(n_unmapped, "unmapped variants removed"))
    
    # Add chrpos column for merging
    df <- df %>%
      dplyr::mutate(chrpos = stringr::str_c(CHROM, POS_1, sep = "_"))
    
    return(df)
  } else {
    message("All variants successfully mapped.")
    return(NULL)
  }
}

#' Liftover variants between builds
#' 
#' This function takes a data frame of variants and lifts them over between builds.
#' Only supports liftover between grch37 and grch38. Unmapped variants are 
#' discarded. By default, the original position is overwritten with the new
#' position. If keep_original_positions is set to TRUE, the original position
#' is retained in a new column as e.g. pos_grch37.
#' 
#' @param data A data frame with at least chromosome and position columns
#' @param chr The name of the column containing chromosome information. Default is "chr".
#' @param pos The name of the column containing position information. Default is "pos".
#' @param from_build The build to lift over from. Default is "grch37".
#' @param to_build The build to lift over to. Default is "grch38".
#' @param keep_original_positions A logical indicating whether to keep the original positions. Default is FALSE.
#' 
#' @return A list containing the lifted data and a data frame of unmapped variants
#' 
#' @export
call_liftover <- function(data, chr = "chr", pos = "pos", from_build = "grch37", to_build = "grc38",
                          keep_original_positions = FALSE) {
  # check if function is being called from mac or linux
  if (Sys.info()["sysname"] == "Darwin") {
    liftOver <- here::here("data", "liftover", "liftOver")
  } else {
    liftOver <- here::here("data", "liftover", "liftOver_linux")
  }
  
  # assert options are valid for builds and set chain file
  if (from_build == "grch37" && to_build == "grch38") {
    chain_file <- here::here("data", "liftover", "hg19ToHg38.over.chain.gz")
  } else if (from_build == "grch38" && to_build == "grch37") {
    chain_file <- here::here("data", "liftover", "hg38ToHg19.over.chain.gz")
  } else {
    stop("Invalid build options. From/to must be grch37 or grch38.")
  }
  
  # write a temporary bed file for use with liftover
  bed <- to_bed(data, chrom = chr, position = pos)
  temp_in <- tempfile(pattern = from_build, fileext = ".bed")
  readr::write_tsv(bed, temp_in, col_names = FALSE)
  
  # create a tempfile for the liftover output
  temp_out <- tempfile(pattern = to_build, fileext = ".bed")
  temp_unmapped <- tempfile(pattern = to_build, fileext = ".unmapped")
  
  # make a system2 call to the liftover executable with given chain file
  system2(command = liftOver,
          args = c(temp_in,
                   chain_file,
                   temp_out,
                   temp_unmapped),
          stdout = TRUE)
  
  # read in the liftover output
  bed_lifted <- readr::read_table(temp_out, col_names = FALSE)
  
  # read in the unmapped variants and 
  data_unmapped <- read_unmapped_variants(temp_unmapped)
  
  # drop unmapped variants from original dataset
  if(!is.null(bed_unmapped)) {
    data_lifted <- data %>%
      dplyr::mutate(chrpos = stringr::str_c(chr, pos, sep = "_")) %>%
      dplyr::filter(chrpos %in% bed_unmapped[[chrpos]]) %>%
      dplyr::select(-chrpos)
  }
  
  # assert that data_lifted and data now have the same number of rows
  if (nrow(bed_lifted) != nrow(data_lifted)) {
    stop("Number of rows in lifted data and original data should match ",
         "after dropping unmapped variant. Check liftover output.")
  }
  
  # rename the original position column to position_from_build
  if(keep_original_positions) {
    new_col <- paste0("pos_", from_build)
    data_lifted <- data_lifted %>%
      dplyr::mutate(!!new_col := .data[[pos]])
  }

  # overwrite the original position with the new position
  data_lifted <- data_lifted %>%
    dplyr::mutate(!!pos := bed_lifted[[2]])
  
  # cleanup temp files
  unlink(c(temp_in, temp_out, temp_unmapped))
  
  return(list(data_lifted, data_unmapped))
}