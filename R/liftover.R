#' Create a BED file from a data frame
#'
#' This function takes a data frame and creates a BED file from it.
#' Requires only chromosome and position to do so.
#' Note this assumes that for all positions you are working with
#' SNPs and not indels, and it formats using the 0-start, half-open
#' system for BED files suitable for the command-line liftover tool.
#' This means the original position is in the output pos column,
#' while pos0 contains the 0-based count of the position. For a
#' discussion of this, [see the UCSC Genome Browser blog article](https://genome-blog.gi.ucsc.edu/blog/2016/12/12/the-ucsc-genome-browser-coordinate-counting-systems/).
#'
#' @param data A data frame with at least chromosome and position columns
#' @param chrom The name of the column containing chromosome information. Default is "chr".
#' @param position The name of the column containing position information. Default is "pos".
#'
#' @return A data frame with chromosome, position0, and position columns
#'
#' @export
to_bed <- function(data, chrom = "chr", position = "pos") {
  data <- data %>%
    tibble::as_tibble() %>%
    dplyr::mutate(!!chrom := stringr::str_c("chr", .data[[chrom]]),
                  pos0 = .data[[position]] - 1) %>%
    dplyr::select({{ chrom }}, pos0 , {{ position }})

  colnames(data) <- c("chr", "pos0", "pos1")

  return(data)
}

#' Read in unmapped variants
#'
#' This function reads in a file of unmapped variants and returns a data frame,
#' where the unmapped variants are output generated by the liftover tool.
#'
#' @param filename The name of the file containing unmapped variants
#'
#' @return A data frame with chromosome, position0, and position1 columns
#'
#' @export
read_unmapped_variants <- function(filename) {
  # Read the file and filter out lines starting with '#'
  lines <- readr::read_lines(filename) %>%
    purrr::keep(~ !stringr::str_starts(., '#'))

  if (length(lines) > 0) {
    # Convert lines to a single string and read into a data frame
    df <- readr::read_delim(paste(lines, collapse = "\n"),
                            col_names = c('CHROM', 'POS_0', 'POS_1')) %>%
      dplyr::mutate(CHROM = stringr::str_replace_all(CHROM, "chr", ""))

    n_unmapped <- nrow(df)
    message(paste(n_unmapped, "unmapped variants removed"))

    # Add chrpos column for merging
    df <- df %>%
      dplyr::mutate(chrpos = stringr::str_c(CHROM, POS_1, sep = "_"))

    return(df)
  } else {
    message("All variants successfully mapped.")
    return(NULL)
  }
}

#' Liftover variants between builds
#'
#' This function takes a data frame of variants and lifts them over between builds.
#' Only supports liftover between grch37 and grch38. Unmapped variants are
#' discarded. By default, the original position is overwritten with the new
#' position. If keep_original_positions is set to TRUE, the original position
#' is retained in a new column as e.g. pos_grch37.
#'
#' @param data A data frame with at least chromosome and position columns
#' @param chr The name of the column containing chromosome information. Default is "chr".
#' @param pos The name of the column containing position information. Default is "pos".
#' @param from_build The build to lift over from. Default is "grch37".
#' @param to_build The build to lift over to. Default is "grch38".
#' @param keep_original_positions A logical indicating whether to keep the original positions. Default is FALSE.
#'
#' @return A list containing the lifted data and a data frame of unmapped variants.
#' If all variants were mapped then the second element is NULL.
#'
#' @export
call_liftover <- function(data, chr = "chr", pos = "pos", from_build = "grch37", to_build = "grch38",
                          keep_original_positions = FALSE) {
  # check for liftover files and prompt install if absent
  check_for_liftover()

  # check if function is being called from mac or linux
  if (Sys.info()["sysname"] == "Darwin") {
    liftOver <- here::here("data", "liftover", "liftOver")
  } else {
    liftOver <- here::here("data", "liftover", "liftOver_linux")
  }

  # assert options are valid for builds and set chain file
  if (from_build == "grch37" && to_build == "grch38") {
    chain_file <- here::here("data", "liftover", "hg19ToHg38.over.chain.gz")
  } else if (from_build == "grch38" && to_build == "grch37") {
    chain_file <- here::here("data", "liftover", "hg38ToHg19.over.chain.gz")
  } else {
    stop("Invalid build options. From/to must be grch37 or grch38.")
  }

  # write a temporary bed file for use with liftover
  bed <- to_bed(data, chrom = chr, position = pos)
  temp_in <- tempfile(pattern = from_build, fileext = ".bed")
  readr::write_tsv(bed, temp_in, col_names = FALSE)

  # create a tempfile for the liftover output
  temp_out <- tempfile(pattern = to_build, fileext = ".bed")
  temp_unmapped <- tempfile(pattern = to_build, fileext = ".unmapped")

  # make a system2 call to the liftover executable with given chain file
  system2(command = liftOver,
          args = c(temp_in,
                   chain_file,
                   temp_out,
                   temp_unmapped))

  # read in the liftover output
  bed_lifted <- readr::read_table(temp_out, col_names = FALSE)

  # read in the unmapped variants and
  data_unmapped <- read_unmapped_variants(temp_unmapped)

  # drop unmapped variants from original dataset
  if(!is.null(data_unmapped)) {
    data <- data %>%
      dplyr::mutate(chrpos = stringr::str_c(chr, pos, sep = "_")) %>%
      dplyr::filter(!chrpos %in% data_unmapped[['chrpos']]) %>%
      dplyr::select(-chrpos)
  }

  # assert that data_lifted and data now have the same number of rows
  if (nrow(bed_lifted) != nrow(data)) {
    print(bed_lifted)
    stop(glue::glue("Number of rows in ",
                    "lifted data ({nrow(bed_lifted)}) ",
                    "and original data ({nrow(data)})"),
         " should match after dropping unmapped variants.",
         " Check liftover output.")
  }

  # rename the original position column to position_from_build
  if(keep_original_positions) {
    new_col <- paste0("pos_", from_build)
    data <- data %>%
      dplyr::mutate(!!new_col := .data[[pos]])
  }

  # overwrite the original position with the new position
  data <- data %>%
    dplyr::mutate(!!pos := bed_lifted[[3]])

  # cleanup temp files
  unlink(c(temp_in, temp_out, temp_unmapped))

  return(list(data, data_unmapped))
}
